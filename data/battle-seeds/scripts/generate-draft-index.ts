/**
 * Draft Battle Index Generator (publishState-driven)
 *
 * Policy: classify draft vs published by the literal publishState value in each
 * battle seed source file instead of directory layout.
 *  - Scan all .ja.ts under src/battle (excluding this generated index)
 *  - Regex extract publishState: 'xxxx'
 *  - Include file if state !== 'published'
 *  - Missing publishState => treat as published (backward compat)
 * Output: src/battle/__drafts/index.generated.ts exporting draftBattleMap
 */
import { promises as fs } from 'fs';
import * as path from 'path';

const SCAN_ROOT = path.resolve(process.cwd(), 'src/battle');
const OUT_DIR = path.join(SCAN_ROOT, '__drafts');
const OUT_FILE = path.join(OUT_DIR, 'index.generated.ts');

async function listAllJaFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const e of entries) {
    if (e.name.startsWith('.')) continue; // skip dotfiles / system dirs
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      const nested = await listAllJaFiles(full);
      files.push(...nested);
    } else if (e.isFile() && e.name.endsWith('.ja.ts')) {
      files.push(full);
    }
  }
  return files;
}

const PUBLISH_STATE_REGEX = /publishState\s*:\s*['"]([a-zA-Z0-9_-]+)['"]/;

async function classifyDraftsByPublishState(
  all: string[],
): Promise<Array<{ file: string; state: string }>> {
  const out: Array<{ file: string; state: string }> = [];
  for (const abs of all) {
    if (abs.endsWith('index.generated.ts')) continue; // skip self
    const content = await fs.readFile(abs, 'utf8');
    const m = content.match(PUBLISH_STATE_REGEX);
    const state = m ? m[1] : 'published';
    if (state !== 'published') {
      out.push({ file: abs, state });
    }
  }
  return out;
}

function toImportId(absPath: string): { importPath: string; key: string } {
  // import path relative to OUT_DIR
  const relFromOutDir = path.relative(OUT_DIR, absPath).replace(/\\/g, '/');
  const key = path.basename(absPath);
  const importPath = relFromOutDir.replace(/\.ts$/, '');
  if (importPath.startsWith('.')) {
    return { importPath, key };
  }
  return { importPath: `./${importPath}`, key };
}

async function generate() {
  const scanRootExists = await fs
    .access(SCAN_ROOT)
    .then(() => true)
    .catch(() => false);
  if (!scanRootExists) {
    throw new Error(`Scan root not found: ${SCAN_ROOT}`);
  }
  await fs.mkdir(OUT_DIR, { recursive: true });
  const all = await listAllJaFiles(SCAN_ROOT);
  const drafts = await classifyDraftsByPublishState(all);
  const files = drafts.map((d) => d.file);
  const imports: string[] = [];
  const mapEntries: string[] = [];
  // Detect duplicate basenames (risk of overwrite)
  const nameCounts: Record<string, number> = {};
  files.forEach((f) => {
    const base = path.basename(f);
    nameCounts[base] = (nameCounts[base] ?? 0) + 1;
  });
  files.sort();
  files.forEach((abs, idx) => {
    const { importPath, key } = toImportId(abs);
    const varName = `d${idx}`;
    imports.push(`import ${varName} from '${importPath}';`);
    mapEntries.push(`  '${key}': ${varName},`);
  });
  const content = `// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate-draft-index.ts
// Draft battle seeds discovered by publishState !== 'published'.
import type { Battle } from '@yonokomae/types';
${imports.join('\n')}

export const draftBattleMap: Record<string, Battle> = {
${mapEntries.join('\n')}
};
`;
  await fs.writeFile(OUT_FILE, content, 'utf8');
  // Also create a d.ts for tooling friendliness (lightweight)
  const dts = `// AUTO-GENERATED TYPE DEFINITION
import type { Battle } from '@yonokomae/types';
export declare const draftBattleMap: Record<string, Battle>;
`;
  await fs.writeFile(OUT_FILE.replace(/\.ts$/, '.d.ts'), dts, 'utf8');
  const dupes = Object.entries(nameCounts)
    .filter(([, c]) => c > 1)
    .map(([n, c]) => `${n}(${c})`);
  process.stdout.write(
    `[generate-draft-index] wrote ${OUT_FILE} with ${files.length} draft entries (scan root: ${SCAN_ROOT})` +
      (dupes.length
        ? `\n[generate-draft-index][warning] duplicate basenames: ${dupes.join(', ')}`
        : '') +
      '\n',
  );
}

generate().catch((err) => {
  console.error('[generate-draft-index] failed', err);
  process.exit(1);
});
